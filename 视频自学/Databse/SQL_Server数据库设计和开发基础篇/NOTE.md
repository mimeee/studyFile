1. ### 数据库设计
    - #### 数据库设计在软件开发中所处的地位
        + 软件开发周期
            * 需求分析阶段  分析客户的业务需求和数据处理需求
            * 概要设计阶段  设计数据库的E-R图，确认需求信息的正确和完整
            * 详细设计阶段  将E-R图转换为多张表，进行逻辑设计，并应用数据库设计的三大范式进行审核
            * 代码编写阶段  选择具体数据库进行物理实现
            * 软件测试阶段
            * 安装部署
        + 数据库设计阶段分步
            * 需求分析  独立于任何数据库管理系统
            * 概念结构设计  独立于任何数据库管理系统
            * 逻辑结构设计  与选用的DBMS密切相关
            * 物理结构设计  与选用的DBMS密切相关
            * 数据库实施
            * 数据库运行和维护
    - #### 数据库设计案例
        + 概念结构设计 —— 数据抽象与局部视图
            * 分类：将同一类的事务划分成一个E-R图的实体(如老师、学生)
            * 聚集：确定实体的组成部分，对应于E-R图的属性
            * 下图就是E-R中的实体以及其对应的属性  
                ![entity](image/entity.png)
        + 逻辑结构设计 —— 向关系模型转换
            * 实体键关系的转换规则
                - 一个1:1关系可以转换为一个独立的关系模式，也可以与任意一端所对应的关系模式合并 
                - 一个1:n关系可以转换为一个独立的关系模式，也可以与n端多对应的关系模式合并
                - 一个m:n关系转换为一个关系模式。转换的方法为:与该关系相连的各实体的码以及关系本身的属性均转换为关系的属性，新关系的码为两个相连实体码的组合
                - 三个或三个以上实体间的多元关系转换为一个关系模式
            * 实体键关系(自联系)的转换原则
                - 同一个实体集的实体间的联系，称为自联系，也可按上述实体键关系的转换规则处理，同样也存在 1:1, 1:n, n:m 的关系
                - 比如在学生表中有一个字段是表示班长的，而班长又是一个学生，这就属于自联系中的1:n
            * 将上述概念结构设计转化成逻辑结构设计为下图
                ![relationship](image/relationship.png)
                - 转化过程
                    + 在1:1的关系中，可以将两个表合成一个表，也可以通过一个字段的关联将一个表拆分成两个表。比如，学生和身份证。可以建立一个学生表，一个身份证表，由于其实1:1的关系，所以可以通过在学生总增加一个字段去关联身份证表，或者在身份证表中建立一个字段去关联学生表  
                    ![](image/1-1student.png)  
                    ![](image/1-1status.png)
                    + 在1：N的关系中，在N的表中建立一个字段去关联1的表即可。如学生和专业，可以在学生字段中添加一个字段代表其所对应的专业。
                    ![](image/1-nstudent.png)  
                    ![](image/1-nmajor.png)
                    + 在N:M的关系中则需要在建立一张新的表去表示关系。如课程和学生，需要建立一张新的表，其中包含代表课程的字段、学生的字段以及其关系(这里可以是成绩)的字段。当然，这个新建的表不一定只是表示两个实体的多对多的关系，也可以表示三个或者三个以上的实体的关系，只要有字段代表即可。比如说学生、课程、考场，可以有的字段就是学生编号，课程编号，考场编号，成绩。
                    ![](image/n-mrelationship.png)  
    - #### 数据库设计规范
        + 数据库设计三范式
            * 第一范式(1NF) 属性不可分  
                - 目标: 确保每列的原子性
                - 如果每列都是不可再分的最小数据单元，则满足第一范式
                - 示例  
                ![满足](image/design_stan_one_correct.png)  
                ![不满足](image/design_stan_one_incorrect.png)
            * 第二范式(2NF) 
                - 每个表只描述一件事情
                - 每条记录有唯一标识列
                - 示例 产品的价格只依赖与产品，订单的时间只依赖与订单。应该分成两个表   
                ![满足](image/design_stan_two_correct.png.png)  
                ![不满足](image/design_stan_two_incorrect.png.png)  
            * 第三范式(3NF)
                - 数据库表中不包含已在其他表中已包含的非主关键字信息
                - 示例 在产品的表中已经记录产品价格，这里就没必要在记录的  
                ![](image/design_stan_three_incorrect.png)
            * 第四范式(4NF)
            * 第五范式(5NF)
            * BC范式(BCNF)
            * 满足最低要求的范式是第一范式。在第一范式的基础上进一步满足更多要求的称为第二范式，其余范式以此类推。一般说来，数据库只需要满足第三范式就行了。
        + 良好的数据库设计
            * 节省数据的存储空间
            * 能够保证数据的完整性
            * 方便进行数据库应用系统的开发
        + 糟糕的数据库设计
            * 数据冗余、存储空间浪费
                - 更新异常，就是修改一个字段的内容要对多条记录进行修改
                - 添加异常，添加一条记录可能会需要虚拟一些暂时还不存在的数据
                - 删除异常，删除一条记录的时候，可能会把其他相关的记录一并删除
            * 内存空间浪费
            * 数据更新和插入的异常
2. 